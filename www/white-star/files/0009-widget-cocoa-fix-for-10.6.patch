From 5e1029ae76f712b6cba9523d62d08d4542240a05 Mon Sep 17 00:00:00 2001
From: barracuda156 <vital.had@gmail.com>
Date: Sun, 14 Jan 2024 06:47:18 +0800
Subject: [PATCH 09/10] widget/cocoa: fix for 10.6

---
 gfx/thebes/gfxFontUtils.h             | 41 ++++++++++++++++++---------
 widget/cocoa/GfxInfo.mm               |  6 +++-
 widget/cocoa/OSXNotificationCenter.mm | 11 ++++++-
 widget/cocoa/TextInputHandler.mm      |  3 ++
 widget/cocoa/nsChildView.h            |  2 ++
 widget/cocoa/nsChildView.mm           | 20 ++++++-------
 widget/cocoa/nsCocoaUtils.mm          |  2 +-
 widget/cocoa/nsCocoaWindow.mm         |  9 ++++--
 widget/cocoa/nsDragService.h          |  2 +-
 widget/cocoa/nsDragService.mm         | 11 ++++---
 widget/cocoa/nsFilePicker.mm          |  3 +-
 widget/cocoa/nsMacWebAppUtils.mm      |  2 +-
 widget/cocoa/nsPrintOptionsX.mm       |  2 +-
 13 files changed, 74 insertions(+), 40 deletions(-)

diff --git gfx/thebes/gfxFontUtils.h gfx/thebes/gfxFontUtils.h
index bbda813660..26d1fcc782 100644
--- gfx/thebes/gfxFontUtils.h
+++ gfx/thebes/gfxFontUtils.h
@@ -325,7 +325,8 @@ namespace mozilla {
 
 // Byte-swapping types and name table structure definitions moved from
 // gfxFontUtils.cpp to .h file so that gfxFont.cpp can also refer to them
-#pragma pack(1)
+
+// #pragma pack(1)
 
 struct AutoSwap_PRUint16 {
 #ifdef __SUNPRO_CC
@@ -623,7 +624,7 @@ struct CPALHeaderVersion0 {
     AutoSwap_PRUint32    offsetFirstColorRecord;
 };
 
-#pragma pack()
+// #pragma pack()
 
 // Return just the highest bit of the given value, i.e., the highest
 // power of 2 that is <= value, or zero if the input value is zero.
@@ -856,18 +857,30 @@ public:
     GetFamilyNameFromTable(hb_blob_t *aNameTable,
                            nsAString& aFamilyName);
 
-    // Find the table directory entry for a given table tag, in a (validated)
-    // buffer of 'sfnt' data. Returns null if the tag is not present.
-    static mozilla::TableDirEntry*
-    FindTableDirEntry(const void* aFontData, uint32_t aTableTag);
-
-    // Return a blob that wraps a table found within a buffer of font data.
-    // The blob does NOT own its data; caller guarantees that the buffer
-    // will remain valid at least as long as the blob.
-    // Returns null if the specified table is not found.
-    // This method assumes aFontData is valid 'sfnt' data; before using this,
-    // caller is responsible to do any sanitization/validation necessary.
-    static hb_blob_t*
+    // Find the table directory entry for a given table tag, in a (validated)
+
+    // buffer of 'sfnt' data. Returns null if the tag is not present.
+
+    static mozilla::TableDirEntry*
+
+    FindTableDirEntry(const void* aFontData, uint32_t aTableTag);
+
+
+
+    // Return a blob that wraps a table found within a buffer of font data.
+
+    // The blob does NOT own its data; caller guarantees that the buffer
+
+    // will remain valid at least as long as the blob.
+
+    // Returns null if the specified table is not found.
+
+    // This method assumes aFontData is valid 'sfnt' data; before using this,
+
+    // caller is responsible to do any sanitization/validation necessary.
+
+    static hb_blob_t*
+
     GetTableFromFontData(const void* aFontData, uint32_t aTableTag);
 
     // create a new name table and build a new font with that name table
diff --git widget/cocoa/GfxInfo.mm widget/cocoa/GfxInfo.mm
index 2b8949c7d2..5317c30d91 100644
--- widget/cocoa/GfxInfo.mm
+++ widget/cocoa/GfxInfo.mm
@@ -359,7 +359,11 @@ GfxInfo::FindMonitors(JSContext* aCx, JS::HandleObject aOutArray)
   // CVDisplayLinkGetNominalOutputVideoRefreshPeriod, but that's a little
   // involved. Ideally we could query it from vsync. For now, we leave it out.
   int32_t deviceCount = 0;
-  for (NSScreen* screen in [NSScreen screens]) {
+  NSArray *screens = [NSScreen screens];
+  size_t screencount = [screens count];
+  size_t i;
+  for(i=0; i<screencount; i++) {
+    NSScreen *screen = [screens objectAtIndex:i];
     NSRect rect = [screen frame];
 
     JS::Rooted<JSObject*> obj(aCx, JS_NewPlainObject(aCx));
diff --git widget/cocoa/OSXNotificationCenter.mm widget/cocoa/OSXNotificationCenter.mm
index 98d63685c8..a7e434d381 100644
--- widget/cocoa/OSXNotificationCenter.mm
+++ widget/cocoa/OSXNotificationCenter.mm
@@ -106,6 +106,7 @@ enum {
 - (void)userNotificationCenter:(id<FakeNSUserNotificationCenter>)center
        didActivateNotification:(id<FakeNSUserNotification>)notification
 {
+#if(0)
   unsigned long long additionalActionIndex = ULLONG_MAX;
   if ([notification respondsToSelector:@selector(_alternateActionIndex)]) {
     NSNumber *alternateActionIndex = [(NSObject*)notification valueForKey:@"_alternateActionIndex"];
@@ -114,6 +115,7 @@ enum {
   mOSXNC->OnActivate([[notification userInfo] valueForKey:@"name"],
                      notification.activationType,
                      additionalActionIndex);
+#endif
 }
 
 - (BOOL)userNotificationCenter:(id<FakeNSUserNotificationCenter>)center
@@ -127,18 +129,22 @@ enum {
 - (void)userNotificationCenter:(id<FakeNSUserNotificationCenter>)center
   didRemoveDeliveredNotifications:(NSArray *)notifications
 {
+#if(0)
   for (id<FakeNSUserNotification> notification in notifications) {
     NSString *name = [[notification userInfo] valueForKey:@"name"];
     mOSXNC->CloseAlertCocoaString(name);
   }
+#endif
 }
 
 // This is an undocumented method that we need to be notified if a user clicks the close button.
 - (void)userNotificationCenter:(id<FakeNSUserNotificationCenter>)center
   didDismissAlert:(id<FakeNSUserNotification>)notification
 {
+#if(0)
   NSString *name = [[notification userInfo] valueForKey:@"name"];
   mOSXNC->CloseAlertCocoaString(name);
+#endif
 }
 
 @end
@@ -324,7 +330,7 @@ OSXNotificationCenter::ShowAlert(nsIAlertNotification* aAlert,
 
       notification.hasActionButton = YES;
       notification.actionButtonTitle = nsCocoaUtils::ToNSString(actionButtonTitle);
-
+#if(0)
       [(NSObject*)notification setValue:@(YES) forKey:@"_showsButtons"];
       [(NSObject*)notification setValue:@(YES) forKey:@"_alwaysShowAlternateActionMenu"];
       [(NSObject*)notification setValue:@[
@@ -332,6 +338,7 @@ OSXNotificationCenter::ShowAlert(nsIAlertNotification* aAlert,
                                           nsCocoaUtils::ToNSString(settingsButtonTitle)
                                           ]
                                forKey:@"_alternateActionButtonTitles"];
+#endif
     }
   }
   nsAutoString name;
@@ -433,6 +440,7 @@ OSXNotificationCenter::CloseAlertCocoaString(NSString *aAlertName)
   }
 
   NSArray *notifications = [GetNotificationCenter() deliveredNotifications];
+#if(0)
   for (id<FakeNSUserNotification> notification in notifications) {
     NSString *name = [[notification userInfo] valueForKey:@"name"];
     if ([name isEqualToString:aAlertName]) {
@@ -441,6 +449,7 @@ OSXNotificationCenter::CloseAlertCocoaString(NSString *aAlertName)
       break;
     }
   }
+#endif
 
   for (unsigned int i = 0; i < mActiveAlerts.Length(); i++) {
     OSXNotificationInfo *osxni = mActiveAlerts[i];
diff --git widget/cocoa/TextInputHandler.mm widget/cocoa/TextInputHandler.mm
index 7232b00361..2095c48da3 100644
--- widget/cocoa/TextInputHandler.mm
+++ widget/cocoa/TextInputHandler.mm
@@ -1,3 +1,5 @@
+#if(0) // Broken code.
+
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=2 sw=2 et tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
@@ -4157,3 +4159,4 @@ TextInputHandlerBase::EnsureSecureEventInputDisabled()
     TextInputHandlerBase::DisableSecureEventInput();
   }
 }
+#endif
diff --git widget/cocoa/nsChildView.h widget/cocoa/nsChildView.h
index 7bd02c3075..e41f2ef5c7 100644
--- widget/cocoa/nsChildView.h
+++ widget/cocoa/nsChildView.h
@@ -135,6 +135,7 @@ enum {
 - (NSRect)convertRectToScreen:(NSRect)aRect;
 @end
 
+#ifdef __LP64__
 enum {
   NSEventSwipeTrackingLockDirection = 0x1 << 0,
   NSEventSwipeTrackingClampGestureAmount = 0x1 << 1
@@ -159,6 +160,7 @@ typedef NSInteger NSEventGestureAxis;
                                max:(CGFloat)maxDampenThreshold
                       usingHandler:(void (^)(CGFloat gestureAmount, NSEventPhase phase, BOOL isComplete, BOOL *stop))trackingHandler;
 @end
+#endif // #ifdef __LP64__
 #endif // #if !defined(MAC_OS_X_VERSION_10_7) || MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_7
 
 @interface ChildView : NSView<
diff --git widget/cocoa/nsChildView.mm widget/cocoa/nsChildView.mm
index 5184be4149..9b3a236340 100644
--- widget/cocoa/nsChildView.mm
+++ widget/cocoa/nsChildView.mm
@@ -301,7 +301,7 @@ public:
                   LayoutDeviceIntRegion());
   void EndUpdate(bool aKeepSurface = false);
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   void UpdateIfNeeded(const LayoutDeviceIntSize& aNewSize,
                       const LayoutDeviceIntRegion& aDirtyRegion,
                       void (^aCallback)(gfx::DrawTarget*,
@@ -778,7 +778,7 @@ bool nsChildView::IsVisible() const
 // private method -[NSWindow _setNeedsDisplayInRect:]. Our BaseWindow
 // implementation of that method is augmented to let us ignore those calls
 // using -[BaseWindow disable/enableSetNeedsDisplay].
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
 static void
 ManipulateViewWithoutNeedingDisplay(NSView* aView, void (^aCallback)())
 {
@@ -811,7 +811,7 @@ NS_IMETHODIMP nsChildView::Show(bool aState)
     // no pool in place.
     nsAutoreleasePool localPool;
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
     ManipulateViewWithoutNeedingDisplay(mView, ^{
       [mView setHidden:!aState];
     });
@@ -1054,7 +1054,7 @@ NS_IMETHODIMP nsChildView::Move(double aX, double aY)
   mBounds.x = x;
   mBounds.y = y;
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   ManipulateViewWithoutNeedingDisplay(mView, ^{
     [mView setFrame:DevPixelsToCocoaPoints(mBounds)];
   });
@@ -1083,7 +1083,7 @@ NS_IMETHODIMP nsChildView::Resize(double aWidth, double aHeight, bool aRepaint)
   mBounds.width  = width;
   mBounds.height = height;
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   ManipulateViewWithoutNeedingDisplay(mView, ^{
     [mView setFrame:DevPixelsToCocoaPoints(mBounds)];
   });
@@ -1126,7 +1126,7 @@ NS_IMETHODIMP nsChildView::Resize(double aX, double aY,
     mBounds.height = height;
   }
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   ManipulateViewWithoutNeedingDisplay(mView, ^{
     [mView setFrame:DevPixelsToCocoaPoints(mBounds)];
   });
@@ -2156,7 +2156,7 @@ nsChildView::MaybeDrawResizeIndicator(GLManager* aManager)
   }
 
   LayoutDeviceIntSize size = mResizeIndicatorRect.Size();
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   mResizerImage->UpdateIfNeeded(size, LayoutDeviceIntRegion(), ^(gfx::DrawTarget* drawTarget, const LayoutDeviceIntRegion& updateRegion) {
     ClearRegion(drawTarget, updateRegion);
     gfx::BorrowedCGContext borrow(drawTarget);
@@ -2417,7 +2417,7 @@ nsChildView::MaybeDrawRoundedCorners(GLManager* aManager,
   }
 
   LayoutDeviceIntSize size(mDevPixelCornerRadius, mDevPixelCornerRadius);
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   mCornerMaskImage->UpdateIfNeeded(size, LayoutDeviceIntRegion(), ^(gfx::DrawTarget* drawTarget, const LayoutDeviceIntRegion& updateRegion) {
     ClearRegion(drawTarget, updateRegion);
     RefPtr<gfx::PathBuilder> builder = drawTarget->CreatePathBuilder();
@@ -3371,7 +3371,7 @@ NSEvent* gLastDragMouseDownEvent = nil;
 // It seems to have something to do with the secret underlying NSInputContext
 // and NSTSMInputContext, which became NSTextInputContext in 10.6.
 
-#if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
 // ComplexTextInputPanel's interpretKeyEvent hack won't work without this.
 // It makes calls to +[NSTextInputContext currentContext], deep in system
 // code, return the appropriate context.
@@ -4732,7 +4732,7 @@ NSEvent* gLastDragMouseDownEvent = nil;
   return NSRectToCGRect(inWindowCoords);
 }
 
-#if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
 static CGSRegionObj
 NewCGSRegionFromRegion(const LayoutDeviceIntRegion& aRegion,
                        CGRect (^aRectConverter)(const LayoutDeviceIntRect&))
diff --git widget/cocoa/nsCocoaUtils.mm widget/cocoa/nsCocoaUtils.mm
index 5f24b165fe..4a1032934b 100644
--- widget/cocoa/nsCocoaUtils.mm
+++ widget/cocoa/nsCocoaUtils.mm
@@ -257,7 +257,7 @@ void nsCocoaUtils::HideOSChromeOnScreen(bool aShouldHide)
   NS_ASSERTION(sHiddenCount >= 0, "Unbalanced HideMenuAndDockForWindow calls");
 
 
-#if defined(MAC_OS_X_VERSION_10_5) && (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_5)
+#if defined(MAC_OS_X_VERSION_10_5) && (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_6)
   if (sHiddenCount <= 0) {
     ::SetSystemUIMode(kUIModeNormal, 0);
   } else {
diff --git widget/cocoa/nsCocoaWindow.mm widget/cocoa/nsCocoaWindow.mm
index ef9b2b22f7..756fc2dd05 100644
--- widget/cocoa/nsCocoaWindow.mm
+++ widget/cocoa/nsCocoaWindow.mm
@@ -1408,6 +1408,8 @@ nsCocoaWindow::PerformFullscreenTransition(FullscreenTransitionStage aStage,
                                            nsISupports* aData,
                                            nsIRunnable* aCallback)
 {
+// We don't have CoreAnimation, so essentially, don't do anything!
+#if(0)
   auto data = static_cast<FullscreenTransitionData*>(aData);
   FullscreenTransitionDelegate* delegate =
     [[FullscreenTransitionDelegate alloc] init];
@@ -1430,6 +1432,7 @@ nsCocoaWindow::PerformFullscreenTransition(FullscreenTransitionStage aStage,
   [mFullscreenTransitionAnimation setDelegate:delegate];
   [mFullscreenTransitionAnimation setDuration:aDuration / 1000.0];
   [mFullscreenTransitionAnimation startAnimation];
+#endif
 }
 
 void nsCocoaWindow::EnteredFullScreen(bool aFullScreen, bool aNativeMode)
@@ -2811,9 +2814,9 @@ static NSMutableSet *gSwizzledFrameViewClasses = nil;
 
 #endif
 
-#if (!defined(MAC_OS_X_VERSION_10_8) && defined(MAC_OS_X_VERSION_10_6)) \
+#if (!defined(MAC_OS_X_VERSION_10_8) && defined(MAC_OS_X_VERSION_10_7)) \
     || MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_8 \
-    && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+    && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
 
 @interface NSImage(ImageCreationWithDrawingHandler)
 + (NSImage *)imageWithSize:(NSSize)size
@@ -2838,7 +2841,7 @@ static NSMutableSet *gSwizzledFrameViewClasses = nil;
     return [super _cornerMask];
   }
 
-#if !defined(MAC_OS_X_VERSION_10_6)  &&  (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_5)
+#if !defined(MAC_OS_X_VERSION_10_7)  &&  (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_6)
   return [super _cornerMask];
 #else
   CGFloat radius = 4.0f;
diff --git widget/cocoa/nsDragService.h widget/cocoa/nsDragService.h
index bf291385a9..07b440bc8d 100644
--- widget/cocoa/nsDragService.h
+++ widget/cocoa/nsDragService.h
@@ -41,7 +41,7 @@ private:
                               nsIntRect* aDragRect,
                               nsIScriptableRegion* aRegion);
   bool IsValidType(NSString* availableType, bool allowFileURL);
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   NSString* GetStringForType(NSPasteboardItem* item, const NSString* type,
                              bool allowFileURL = false);
   NSString* GetTitleForURL(NSPasteboardItem* item);
diff --git widget/cocoa/nsDragService.mm widget/cocoa/nsDragService.mm
index d7ae526ead..831d77b7f2 100644
--- widget/cocoa/nsDragService.mm
+++ widget/cocoa/nsDragService.mm
@@ -233,8 +233,7 @@ nsDragService::ConstructDragImage(nsIDOMNode* aDOMNode,
   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 }
 
-
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
 bool
 nsDragService::IsValidType(NSString* availableType, bool allowFileURL)
 {
@@ -441,7 +440,7 @@ nsDragService::GetData(nsITransferable* aTransferable, uint32_t aItemIndex)
 
     MOZ_LOG(sCocoaLog, LogLevel::Info, ("nsDragService::GetData: looking for clipboard data of type %s\n", flavorStr.get()));
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
     NSArray* droppedItems = [globalDragPboard pasteboardItems];
     if (!droppedItems) {
       continue;
@@ -459,7 +458,7 @@ nsDragService::GetData(nsITransferable* aTransferable, uint32_t aItemIndex)
 #endif
 
     if (flavorStr.EqualsLiteral(kFileMime)) {
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
       NSString* filePath = GetFilePath(item);
 #else
        NSArray* pFiles = [globalDragPboard propertyListForType:NSFilenamesPboardType];
@@ -490,7 +489,7 @@ nsDragService::GetData(nsITransferable* aTransferable, uint32_t aItemIndex)
       break;
     }
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
     NSString* pString = nil;
     if (flavorStr.EqualsLiteral(kUnicodeMime)) {
       pString = GetStringForType(item, (const NSString*)kUTTypeUTF8PlainText);
@@ -655,7 +654,7 @@ nsDragService::IsDataFlavorSupported(const char *aDataFlavor, bool *_retval)
     }
   }
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   const NSString* type = nil;
   bool allowFileURL = false;
   if (dataFlavor.EqualsLiteral(kFileMime)) {
diff --git widget/cocoa/nsFilePicker.mm widget/cocoa/nsFilePicker.mm
index ea1ddda3d1..45d666e15f 100644
--- widget/cocoa/nsFilePicker.mm
+++ widget/cocoa/nsFilePicker.mm
@@ -364,7 +364,8 @@ nsFilePicker::GetLocalFiles(const nsString& inTitle, bool inAllowMultiple, nsCOM
   // it creates a new array each time.
   // We are using Fast Enumeration, thus the NSURL array is created once then
   // iterated.
-  for (NSURL* url in [thePanel URLs]) {
+  for (unsigned int i = 0; i < [[thePanel URLs] count]; i++) {
+    NSURL *url = [[thePanel URLs] objectAtIndex:i];
     if (!url) {
       continue;
     }
diff --git widget/cocoa/nsMacWebAppUtils.mm widget/cocoa/nsMacWebAppUtils.mm
index 6c588d273b..95259becb8 100755
--- widget/cocoa/nsMacWebAppUtils.mm
+++ widget/cocoa/nsMacWebAppUtils.mm
@@ -70,7 +70,7 @@ NS_IMETHODIMP nsMacWebAppUtils::TrashApp(const nsAString& path, nsITrashAppCallb
   NSString* tempString = [NSString stringWithCharacters:reinterpret_cast<const unichar*>(((nsString)path).get())
                                    length:path.Length()];
 
-#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)
+#if defined(MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_6)
   [[NSWorkspace sharedWorkspace] recycleURLs: [NSArray arrayWithObject:[NSURL fileURLWithPath:tempString]]
     completionHandler: ^(NSDictionary *newURLs, NSError *error) {
       nsresult rv = (error == nil) ? NS_OK : NS_ERROR_FAILURE;
diff --git widget/cocoa/nsPrintOptionsX.mm widget/cocoa/nsPrintOptionsX.mm
index f86f5601af..b893180baf 100644
--- widget/cocoa/nsPrintOptionsX.mm
+++ widget/cocoa/nsPrintOptionsX.mm
@@ -9,7 +9,7 @@
 #include "nsPrintOptionsX.h"
 #include "nsPrintSettingsX.h"
 
-#if defined(MAC_OS_X_VERSION_10_5) && (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_5)
+#if defined(MAC_OS_X_VERSION_10_5) && (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_6)
 NSString *const NSPrintJobSavingFileNameExtensionHidden = @"NSPrintJobSavingFileNameExtensionHidden";
 NSString *const NSPrintSelectionOnly = @"NSPrintSelectionOnly";
 NSString *const NSPrintJobSavingURL = @"NSPrintJobSavingURL";
-- 
2.43.0

