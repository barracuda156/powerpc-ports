From 477620b5011687a8dae931d63d6f6f49b83ff8bd Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <barracuda@macos-powerpc.org>
Date: Sat, 31 Aug 2024 03:26:59 +0800
Subject: [PATCH 17/19] xquartz/X11*: for now restore working code of 1.20.x

---
 hw/xquartz/X11Application.h |   8 +-
 hw/xquartz/X11Application.m | 244 +++++++++---------
 hw/xquartz/X11Controller.h  |  31 ++-
 hw/xquartz/X11Controller.m  | 500 ++++++++++++++++++++----------------
 hw/xquartz/quartzCommon.h   |  55 ++++
 5 files changed, 490 insertions(+), 348 deletions(-)
 create mode 100644 hw/xquartz/quartzCommon.h

diff --git a/hw/xquartz/X11Application.h b/hw/xquartz/X11Application.h
index 8d90df543..740a8070a 100644
--- a/hw/xquartz/X11Application.h
+++ b/hw/xquartz/X11Application.h
@@ -31,11 +31,9 @@
 #ifndef X11APPLICATION_H
 #define X11APPLICATION_H 1
 
-// #include <X11/Xdefs.h>
-
 #if __OBJC__
 
-#include "X11Controller.h"
+#import "X11Controller.h"
 
 @interface X11Application : NSApplication {
     X11Controller *_controller;
@@ -85,7 +83,7 @@ X11ApplicationShowHideMenubar(int state);
 void
 X11ApplicationLaunchClient(const char *cmd);
 
-bool
+Bool
 X11ApplicationCanEnterRandR(void);
 
 void
@@ -119,7 +117,7 @@ X11ApplicationMain(int argc, char **argv, char **envp);
 #define PREFS_FOCUS_ON_NEW_WINDOW     "wm_focus_on_new_window"
 
 #define PREFS_SCROLL_IN_DEV_DIRECTION "scroll_in_device_direction"
-extern bool XQuartzScrollInDeviceDirection;
+extern Bool XQuartzScrollInDeviceDirection;
 
 #define PREFS_SYNC_PB                "sync_pasteboard"
 #define PREFS_SYNC_PB_TO_CLIPBOARD   "sync_pasteboard_to_clipboard"
diff --git a/hw/xquartz/X11Application.m b/hw/xquartz/X11Application.m
index 0d24b1aaa..40507250b 100644
--- a/hw/xquartz/X11Application.m
+++ b/hw/xquartz/X11Application.m
@@ -34,6 +34,8 @@
 #include <dix-config.h>
 #endif
 
+#include "quartzCommon.h"
+
 #include "X11Application.h"
 
 #include "darwin.h"
@@ -46,6 +48,7 @@
 
 #include <mach/mach.h>
 #include <unistd.h>
+#include <AvailabilityMacros.h>
 
 #include <pthread.h>
 
@@ -55,13 +58,11 @@
 extern int
 xpbproxy_run(void);
 
-#define DEFAULTS_FILE X11LIBDIR "/X11/xserver/Xquartz.plist"
-
 #ifndef XSERVER_VERSION
 #define XSERVER_VERSION "?"
 #endif
 
-#if HAVE_LIBDISPATCH
+#ifdef HAVE_LIBDISPATCH
 #include <dispatch/dispatch.h>
 static dispatch_queue_t eventTranslationQueue;
 #endif
@@ -102,50 +103,6 @@ CFStringRef app_prefs_domain_cfstr = NULL;
 #define ALL_KEY_MASKS (NSShiftKeyMask | NSControlKeyMask | \
                        NSAlternateKeyMask | NSCommandKeyMask)
 
-#if APPKIT_APPFLAGS_HACK && MAC_OS_X_VERSION_MAX_ALLOWED >= 101500
-// This was removed from the SDK in 10.15
-@interface NSApplication () {
-@protected
-    /* All instance variables are private */
-    short               _running;
-    struct __appFlags {
-        unsigned int        _hidden:1;
-        unsigned int        _appleEventActivationInProgress:1;
-        unsigned int        _active:1;
-        unsigned int        _hasBeenRun:1;
-        unsigned int        _doingUnhide:1;
-        unsigned int        _delegateReturnsValidRequestor:1;
-        unsigned int        _deactPending:1;
-        unsigned int        _invalidState:1;
-        unsigned int        _invalidEvent:1;
-        unsigned int        _postedWindowsNeedUpdateNote:1;
-        unsigned int        _wantsToActivate:1;
-        unsigned int        _doingHide:1;
-        unsigned int        _dontSendShouldTerminate:1;
-        unsigned int        _ignoresFullScreen:1;
-        unsigned int        _finishedLaunching:1;
-        unsigned int        _hasEventDelegate:1;
-        unsigned int        _appTerminating:1;
-        unsigned int        _didNSOpenOrPrint:1;
-        unsigned int        _inDealloc:1;
-        unsigned int        _pendingDidFinish:1;
-        unsigned int        _hasKeyFocus:1;
-        unsigned int        _panelsNonactivating:1;
-        unsigned int        _hiddenOnLaunch:1;
-        unsigned int        _openStatus:2;
-        unsigned int        _batchOrdering:1;
-        unsigned int        _waitingForTerminationReply:1;
-        unsigned int        _unused:1;
-        unsigned int        _enumeratingMemoryPressureHandlers:1;
-        unsigned int        _didTryRestoringPersistentState:1;
-        unsigned int        _windowDragging:1;
-        unsigned int        _mightBeSwitching:1;
-    }                   _appFlags;
-    id                  _mainMenu;
-}
-@end
-#endif
-
 @interface NSApplication (Internal)
 - (void)_setKeyWindow:(id)window;
 - (void)_setMainWindow:(id)window;
@@ -262,7 +219,7 @@ message_kit_thread(SEL selector, NSObject *arg)
     if (_x_active == state)
         return;
 
-    DEBUG_LOG("state=%d, x_active=%d, \n", state, _x_active);
+    DEBUG_LOG("state=%d, _x_active=%d, \n", state, _x_active);
     if (state) {
         if (bgMouseLocationUpdated) {
             DarwinSendPointerEvents(darwinPointer, MotionNotify, 0,
@@ -298,8 +255,9 @@ message_kit_thread(SEL selector, NSObject *arg)
 {
     /* Don't try sending to X if we haven't initialized.  This can happen if AppKit takes over
      * (eg: uncaught exception) early in launch.
+     * aquaMenuBarHeight is just a proxy for initialization.
      */
-    if (!eventTranslationQueue) {
+    if (!aquaMenuBarHeight) {
         [super sendEvent:e];
         return;
     }
@@ -317,8 +275,6 @@ message_kit_thread(SEL selector, NSObject *arg)
     case NSLeftMouseUp:
     case NSRightMouseUp:
     case NSOtherMouseUp:
-    case NSScrollWheel:
-
         if ([e window] != nil) {
             /* Pointer event has an (AppKit) window. Probably something for the kit. */
             for_x = NO;
@@ -402,11 +358,14 @@ message_kit_thread(SEL selector, NSObject *arg)
                     swallow_keycode = [e keyCode];
                     do_swallow = YES;
                     for_x = NO;
-                } else if (XQuartzEnableKeyEquivalents &&
+#if XPLUGIN_VERSION >= 1
+                }
+                else if (XQuartzEnableKeyEquivalents &&
                          xp_is_symbolic_hotkey_event([e eventRef])) {
                     swallow_keycode = [e keyCode];
                     do_swallow = YES;
                     for_x = NO;
+#endif
                 }
                 else if (XQuartzEnableKeyEquivalents &&
                          [[self mainMenu] performKeyEquivalent:e]) {
@@ -536,18 +495,32 @@ message_kit_thread(SEL selector, NSObject *arg)
         break;          /* for gcc */
     }
 
-    if (for_appkit) {
-        [super sendEvent:e];
-    }
+    if (for_appkit) [super sendEvent:e];
 
     if (for_x) {
+#ifdef __clang__
+        dispatch_async(eventTranslationQueue, ^{
+                           [self sendX11NSEvent:e];
+                       });
+#else
         [self sendX11NSEvent:e];
+#endif
     }
 }
 
+- (void) set_window_menu:(NSArray *)list
+{
+    [_controller set_window_menu:list];
+}
+
+- (void) set_window_menu_check:(NSNumber *)n
+{
+    [_controller set_window_menu_check:n];
+}
+
 - (void) set_apps_menu:(NSArray *)list
 {
-    [self.controller set_apps_menu:list];
+    [_controller set_apps_menu:list];
 }
 
 - (void) set_front_process:unused
@@ -558,6 +531,16 @@ message_kit_thread(SEL selector, NSObject *arg)
         [self activateX:YES];
 }
 
+- (void) set_can_quit:(NSNumber *)state
+{
+    [_controller set_can_quit:[state boolValue]];
+}
+
+- (void) server_ready:unused
+{
+    [_controller server_ready];
+}
+
 - (void) show_hide_menubar:(NSNumber *)state
 {
     /* Also shows/hides the dock */
@@ -570,7 +553,7 @@ message_kit_thread(SEL selector, NSObject *arg)
 
 - (void) launch_client:(NSString *)cmd
 {
-    (void)[self.controller application:self openFile:cmd];
+    (void)[_controller application:self openFile:cmd];
 }
 
 /* user preferences */
@@ -625,8 +608,6 @@ nsarray_to_cfarray(NSArray *in)
 
 static NSMutableArray *
 cfarray_to_nsarray(CFArrayRef in)
-
-- (void) read_defaults
 {
     NSMutableArray *out;
     const CFTypeRef *cf;
@@ -844,7 +825,6 @@ cfarray_to_nsarray(CFArrayRef in)
                           app_prefs_domain_cfstr,
                           kCFPreferencesCurrentUser,
                           kCFPreferencesAnyHost);
-
     CFRelease(x);
 }
 
@@ -858,7 +838,6 @@ cfarray_to_nsarray(CFArrayRef in)
                           app_prefs_domain_cfstr,
                           kCFPreferencesCurrentUser,
                           kCFPreferencesAnyHost);
-
     CFRelease(x);
 }
 
@@ -1194,9 +1173,6 @@ create_thread(void *(*func)(void *), void *arg)
     pthread_attr_init(&attr);
     pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    if (&pthread_attr_set_qos_class_np) {
-        pthread_attr_set_qos_class_np(&attr, QOS_CLASS_USER_INITIATED, 0);
-    }
     pthread_create(&tid, &attr, func, arg);
     pthread_attr_destroy(&attr);
 
@@ -1225,14 +1201,16 @@ X11ApplicationMain(int argc, char **argv, char **envp)
     X11App = (X11Application *)[X11Application sharedApplication];
     init_ports();
 
-        app_prefs_domain_cfstr = (CFStringRef)[[NSBundle mainBundle] bundleIdentifier];
+    app_prefs_domain_cfstr =
+        (CFStringRef)[[NSBundle mainBundle] bundleIdentifier];
 
-        if (app_prefs_domain_cfstr == NULL) {
-            ErrorF("X11ApplicationMain: Unable to determine bundle identifier. Your installation of XQuartz may be broken.\n");
-            app_prefs_domain_cfstr = CFSTR(BUNDLE_ID_PREFIX ".X11");
-        }
+    if (app_prefs_domain_cfstr == NULL) {
+        ErrorF(
+            "X11ApplicationMain: Unable to determine bundle identifier.  Your installation of XQuartz may be broken.\n");
+        app_prefs_domain_cfstr = CFSTR(BUNDLE_ID_PREFIX ".X11");
+    }
 
-        [NSApp read_defaults];
+    [NSApp read_defaults];
     [NSBundle loadNibNamed:@"main" owner:NSApp];
     [[NSNotificationCenter defaultCenter] addObserver:NSApp
                                              selector:@selector (became_key:)
@@ -1248,47 +1226,54 @@ X11ApplicationMain(int argc, char **argv, char **envp)
     /* Calculate the height of the menubar so we can avoid it. */
     aquaMenuBarHeight = [[NSApp mainMenu] menuBarHeight];
 #if ! __LP64__
-        if (!aquaMenuBarHeight) {
-            aquaMenuBarHeight = [NSMenuView menuBarHeight];
-        }
+    if (!aquaMenuBarHeight) {
+        aquaMenuBarHeight = [NSMenuView menuBarHeight];
+    }
 #endif
-        if (!aquaMenuBarHeight) {
-            NSScreen* primaryScreen = NSScreen.screens[0];
-            aquaMenuBarHeight = NSHeight(primaryScreen.frame) - NSMaxY(primaryScreen.visibleFrame);
-        }
+    if (!aquaMenuBarHeight) {
+        NSScreen* primaryScreen = [[NSScreen screens] objectAtIndex:0];
+        aquaMenuBarHeight = NSHeight([primaryScreen frame]) - NSMaxY([primaryScreen visibleFrame]);
+    }
 
-#if HAVE_LIBDISPATCH
-        eventTranslationQueue = dispatch_queue_create(BUNDLE_ID_PREFIX ".X11.NSEventsToX11EventsQueue", NULL);
-        assert(eventTranslationQueue != NULL);
+#ifdef HAVE_LIBDISPATCH
+    eventTranslationQueue = dispatch_queue_create(
+        BUNDLE_ID_PREFIX ".X11.NSEventsToX11EventsQueue", NULL);
+    assert(eventTranslationQueue != NULL);
 #endif
 
-        /* Set the key layout seed before we start the server */
-        last_key_layout = TISCopyCurrentKeyboardLayoutInputSource();
+    /* Set the key layout seed before we start the server */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
+    last_key_layout = TISCopyCurrentKeyboardLayoutInputSource();
 
-        if (!last_key_layout) {
-            ErrorF("X11ApplicationMain: Unable to determine TISCopyCurrentKeyboardLayoutInputSource() at startup.\n");
-        }
+    if (!last_key_layout)
+        ErrorF(
+            "X11ApplicationMain: Unable to determine TISCopyCurrentKeyboardLayoutInputSource() at startup.\n");
+#else
+    KLGetCurrentKeyboardLayout(&last_key_layout);
+    if (!last_key_layout)
+        ErrorF(
+            "X11ApplicationMain: Unable to determine KLGetCurrentKeyboardLayout() at startup.\n");
+#endif
 
-        if (!QuartsResyncKeymap(FALSE)) {
-            ErrorF("X11ApplicationMain: Could not build a valid keymap.\n");
-        }
+    if (!QuartsResyncKeymap(FALSE)) {
+        ErrorF("X11ApplicationMain: Could not build a valid keymap.\n");
+    }
 
-        /* Tell the server thread that it can proceed */
-        QuartzInitServer(argc, argv, envp);
+    /* Tell the server thread that it can proceed */
+    QuartzInitServer(argc, argv, envp);
 
-        /* This must be done after QuartzInitServer because it can result in
-         * an mieqEnqueue() - <rdar://problem/6300249>
-         */
-        check_xinitrc();
+    /* This must be done after QuartzInitServer because it can result in
+     * an mieqEnqueue() - <rdar://problem/6300249>
+     */
+    check_xinitrc();
 
-        create_thread(xpbproxy_x_thread, NULL);
+    create_thread(xpbproxy_x_thread, NULL);
 
 #if XQUARTZ_SPARKLE
-        [[X11App controller] setup_sparkle];
-        [[SUUpdater sharedUpdater] resetUpdateCycle];
-        //    [[SUUpdater sharedUpdater] checkForUpdates:X11App];
+    [[X11App controller] setup_sparkle];
+    [[SUUpdater sharedUpdater] resetUpdateCycle];
+    //    [[SUUpdater sharedUpdater] checkForUpdates:X11App];
 #endif
-    }
 
     [pool release];
     [NSApp run];
@@ -1494,16 +1479,7 @@ wait_for_mieq_init(void);
         goto handle_mouse;
 
     case NSOtherMouseDown:
-        // Get the AppKit button number, and convert it from 0-based to 1-based
-        ev_button = [e buttonNumber] + 1;
-
-        /* Translate middle mouse button (3 in AppKit) to button 2 in X11,
-         * and translate additional mouse buttons (4 and higher in AppKit)
-         * to buttons 8 and higher in X11, to match default behavior of X11
-         * on other platforms
-         */
-        ev_button = (ev_button == 3) ? 2 : (ev_button + 4);
-
+        ev_button = 2;
         ev_type = ButtonPress;
         goto handle_mouse;
 
@@ -1518,9 +1494,7 @@ wait_for_mieq_init(void);
         goto handle_mouse;
 
     case NSOtherMouseUp:
-        // See above comments for NSOtherMouseDown
-        ev_button = [e buttonNumber] + 1;
-        ev_button = (ev_button == 3) ? 2 : (ev_button + 4);
+        ev_button = 2;
         ev_type = ButtonRelease;
         goto handle_mouse;
 
@@ -1535,9 +1509,7 @@ wait_for_mieq_init(void);
         goto handle_mouse;
 
     case NSOtherMouseDragged:
-        // See above comments for NSOtherMouseDown
-        ev_button = [e buttonNumber] + 1;
-        ev_button = (ev_button == 3) ? 2 : (ev_button + 4);
+        ev_button = 2;
         ev_type = MotionNotify;
         goto handle_mouse;
 
@@ -1604,6 +1576,8 @@ handle_mouse:
         }
 
         if (!XQuartzServerVisible && noTestExtensions) {
+#if defined(XPLUGIN_VERSION) && XPLUGIN_VERSION > 0
+            /* Older libXplugin (Tiger/"Stock" Leopard) aren't thread safe, so we can't call xp_find_window from the Appkit thread */
             xp_window_id wid = 0;
             xp_error err;
 
@@ -1616,6 +1590,7 @@ handle_mouse:
             err = xp_find_window(location.x, location.y, 0, &wid);
 
             if (err != XP_Success || (err == XP_Success && wid == 0))
+#endif
             {
                 bgMouseLocation = location;
                 bgMouseLocationUpdated = TRUE;
@@ -1671,17 +1646,54 @@ handle_mouse:
 
     case NSScrollWheel:
     {
+#if MAC_OS_X_VERSION_MAX_ALLOWED < 1050
+        float deltaX = [e deltaX];
+        float deltaY = [e deltaY];
+        BOOL isContinuous = NO;
+#else
         CGFloat deltaX = [e deltaX];
         CGFloat deltaY = [e deltaY];
         CGEventRef cge = [e CGEvent];
         BOOL isContinuous =
             CGEventGetIntegerValueField(cge, kCGScrollWheelEventIsContinuous);
+
+#if 0
+        /* Scale the scroll value by line height */
+        CGEventSourceRef source = CGEventCreateSourceFromEvent(cge);
+        if (source) {
+            double lineHeight = CGEventSourceGetPixelsPerLine(source);
+            CFRelease(source);
+            
+            /* There's no real reason for the 1/5 ratio here other than that
+             * it feels like a good ratio after some testing.
+             */
+            
+            deltaX *= lineHeight / 5.0;
+            deltaY *= lineHeight / 5.0;
+        }
+#endif
+#endif
         
-        if (XQuartzScrollInDeviceDirection &&
+#if !defined(XPLUGIN_VERSION) || XPLUGIN_VERSION == 0
+        /* If we're in the background, we need to send a MotionNotify event
+         * first, since we aren't getting them on background mouse motion
+         */
+        if (!XQuartzServerVisible && noTestExtensions) {
+            bgMouseLocationUpdated = FALSE;
+            DarwinSendPointerEvents(darwinPointer, MotionNotify, 0,
+                                    location.x, location.y,
+                                    0.0, 0.0);
+        }
+#endif
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
+        // TODO: Change 1117 to NSAppKitVersionNumber10_7 when it is defined
+        if (NSAppKitVersionNumber >= 1117 &&
+            XQuartzScrollInDeviceDirection &&
             [e isDirectionInvertedFromDevice]) {
             deltaX *= -1;
             deltaY *= -1;
         }
+#endif
         /* This hack is in place to better deal with "clicky" scroll wheels:
          * http://xquartz.macosforge.org/trac/ticket/562
          */
diff --git a/hw/xquartz/X11Controller.h b/hw/xquartz/X11Controller.h
index bcd244d67..c7d49691d 100644
--- a/hw/xquartz/X11Controller.h
+++ b/hw/xquartz/X11Controller.h
@@ -46,6 +46,16 @@
 #undef BOOL
 #endif
 
+#ifndef NSINTEGER_DEFINED
+#if __LP64__ || NS_BUILD_32_LIKE_64
+typedef long NSInteger;
+typedef unsigned long NSUInteger;
+#else
+typedef int NSInteger;
+typedef unsigned int NSUInteger;
+#endif
+#endif
+
 @interface X11Controller : NSObject
 #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060 && !defined __ppc__
     <NSTableViewDataSource>
@@ -75,17 +85,35 @@
     IBOutlet NSTextField *sync_text2;
     IBOutlet NSPopUpButton *depth;
 
+    IBOutlet NSMenuItem *window_separator;
+    // window_separator is DEPRECATED due to this radar:
+    // <rdar://problem/7088335> NSApplication releases the separator in the Windows menu even though it's an IBOutlet
+    // It is kept around for localization compatibility and is subject to removal "eventually"
+    // If it is !NULL (meaning it is in the nib), it is removed from the menu and released
+
     IBOutlet NSMenuItem *x11_about_item;
     IBOutlet NSMenuItem *dock_window_separator;
     IBOutlet NSMenuItem *apps_separator;
     IBOutlet NSMenuItem *toggle_fullscreen_item;
-
+#ifdef XQUARTZ_SPARKLE
+    NSMenuItem *check_for_updates_item; // Programmatically enabled
+#endif
     IBOutlet NSMenuItem *copy_menu_item;
     IBOutlet NSMenu *dock_apps_menu;
     IBOutlet NSTableView *apps_table;
 
+    NSArray *apps;
+    NSMutableArray *table_apps;
+
     IBOutlet NSMenu *dock_menu;
 
+    // This is where in the Windows menu we'll start (this will be the index of the separator)
+    NSInteger windows_menu_start;
+
+    int checked_window_item;
+    x_list *pending_apps;
+
+    OSX_BOOL finished_launching;
     OSX_BOOL can_quit;
 }
 
@@ -97,6 +125,7 @@
 - (void)updater:(SUUpdater *)updater willInstallUpdate:(SUAppcastItem *)
    update;
 #endif
+- (void)set_can_quit:(OSX_BOOL)state;
 - (void)server_ready;
 - (OSX_BOOL)application:(NSApplication *)app openFile:(NSString *)filename;
 
diff --git a/hw/xquartz/X11Controller.m b/hw/xquartz/X11Controller.m
index 1eaecd550..715e2076f 100644
--- a/hw/xquartz/X11Controller.m
+++ b/hw/xquartz/X11Controller.m
@@ -29,13 +29,16 @@
  */
 
 #include "sanitizedCarbon.h"
+#include <AvailabilityMacros.h>
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
 
-#include "X11Controller.h"
-#include "X11Application.h"
+#include "quartzCommon.h"
+
+#import "X11Controller.h"
+#import "X11Application.h"
 
 #include "opaque.h"
 #include "darwin.h"
@@ -56,27 +59,15 @@
 extern aslclient aslc;
 extern char *bundle_id_prefix;
 
-@interface X11Controller ()
-#ifdef XQUARTZ_SPARKLE
-@property (nonatomic, readwrite, strong) NSMenuItem *check_for_updates_item; // Programatically enabled
-#endif
-
-@property (nonatomic, readwrite, strong) NSArray <NSArray <NSString *> *> *apps;
-@property (nonatomic, readwrite, strong) NSMutableArray <NSMutableArray <NSString *> *> *table_apps;
-@property (nonatomic, readwrite, assign) NSInteger windows_menu_nitems;
-@property (nonatomic, readwrite, assign) int checked_window_item;
-@property (nonatomic, readwrite, assign) x_list *pending_apps;
-@property (nonatomic, readwrite, assign) OSX_BOOL finished_launching;
-@end
-
 @implementation X11Controller
 
 - (void) awakeFromNib
 {
     X11Application *xapp = NSApp;
+    NSArray *array;
 
     /* Point X11Application at ourself. */
-    xapp.controller = self;
+    [xapp set_controller:self];
 
     array = [xapp prefs_get_array:@PREFS_APPSMENU];
     if (array != nil) {
@@ -84,6 +75,7 @@ extern char *bundle_id_prefix;
 
         /* convert from [TITLE1 COMMAND1 TITLE2 COMMAND2 ...]
            to [[TITLE1 COMMAND1] [TITLE2 COMMAND2] ...] format. */
+
         count = [array count];
         if (count > 0
             && ![[array objectAtIndex:0] isKindOfClass:[NSArray class]]) {
@@ -111,7 +103,15 @@ extern char *bundle_id_prefix;
      addObserver: self
         selector: @selector(apps_table_done:)
             name: NSWindowWillCloseNotification
-          object: self.apps_table.window];
+          object: [apps_table window]];
+
+    // Setup data about our Windows menu
+    if (window_separator) {
+        [[window_separator menu] removeItem:window_separator];
+        window_separator = nil;
+    }
+
+    windows_menu_start = [[X11App windowsMenu] numberOfItems];
 }
 
 - (void) item_selected:sender
@@ -122,16 +122,80 @@ extern char *bundle_id_prefix;
                        AppleWMWindowMenuItem, [sender tag]);
 }
 
+- (void) remove_window_menu
+{
+    NSMenu *menu;
+    int count, i;
+
+    /* Work backwards so we don't mess up the indices */
+    menu = [X11App windowsMenu];
+    count = [menu numberOfItems];
+    for (i = count - 1; i >= windows_menu_start; i--)
+        [menu removeItemAtIndex:i];
+
+    count = [dock_menu indexOfItem:dock_window_separator];
+    for (i = 0; i < count; i++)
+        [dock_menu removeItemAtIndex:0];
+}
+
+- (void) install_window_menu:(NSArray *)list
+{
+    NSMenu *menu;
+    NSMenuItem *item;
+    int first, count, i;
+
+    menu = [X11App windowsMenu];
+    first = windows_menu_start + 1;
+    count = [list count];
+
+    // Push a Separator
+    if (count) {
+        [menu addItem:[NSMenuItem separatorItem]];
+    }
+
+    for (i = 0; i < count; i++) {
+        NSString *name, *shortcut;
+
+        name = [[list objectAtIndex:i] objectAtIndex:0];
+        shortcut = [[list objectAtIndex:i] objectAtIndex:1];
+
+        if (windowItemModMask == 0 || windowItemModMask == -1)
+            shortcut = @"";
+
+        item =
+            (NSMenuItem *)[menu addItemWithTitle:name action:
+                           @selector
+                           (item_selected:) keyEquivalent:shortcut];
+        [item setKeyEquivalentModifierMask:(NSUInteger)windowItemModMask];
+        [item setTarget:self];
+        [item setTag:i];
+        [item setEnabled:YES];
+
+        item = (NSMenuItem *)[dock_menu  insertItemWithTitle:name
+                                                      action:@selector
+                              (item_selected:) keyEquivalent:shortcut
+                                                     atIndex:i];
+        [item setKeyEquivalentModifierMask:(NSUInteger)windowItemModMask];
+        [item setTarget:self];
+        [item setTag:i];
+        [item setEnabled:YES];
+    }
+
+    if (checked_window_item >= 0 && checked_window_item < count) {
+        item = (NSMenuItem *)[menu itemAtIndex:first + checked_window_item];
+        [item setState:NSOnState];
+        item = (NSMenuItem *)[dock_menu itemAtIndex:checked_window_item];
+        [item setState:NSOnState];
+    }
+}
+
 - (void) remove_apps_menu
 {
     NSMenu *menu;
     NSMenuItem *item;
     int i;
 
-    NSMenuItem * const apps_separator = self.apps_separator;
-    NSMenu * const dock_apps_menu = self.dock_apps_menu;
-
-    if (self.apps == nil || apps_separator == nil) return;
+    if (apps == nil || apps_separator == nil) return;
 
     menu = [apps_separator menu];
 
@@ -151,13 +215,14 @@ extern char *bundle_id_prefix;
         }
     }
 
-    self.apps = nil;
+    [apps release];
+    apps = nil;
 }
 
-- (void) prepend_apps_item:(NSArray <NSArray <NSString *> *> *)list index:(int)i menu:(NSMenu *)menu
+- (void) prepend_apps_item:(NSArray *)list index:(int)i menu:(NSMenu *)menu
 {
     NSString *title, *shortcut = @"";
-    NSArray <NSString *> *group;
+    NSArray *group;
     NSMenuItem *item;
 
     group = [list objectAtIndex:i];
@@ -181,16 +246,13 @@ extern char *bundle_id_prefix;
     [item setTag:i + 1];                  /* can't be zero, so add one */
 }
 
-- (void) install_apps_menu:(NSArray <NSArray <NSString *> *> *)list
+- (void) install_apps_menu:(NSArray *)list
 {
     NSMenu *menu;
     int i, count;
 
     count = [list count];
 
-    NSMenuItem * const apps_separator = self.apps_separator;
-    NSMenu * const dock_apps_menu = self.dock_apps_menu;
-
     if (count == 0 || apps_separator == nil) return;
 
     menu = [apps_separator menu];
@@ -202,89 +264,28 @@ extern char *bundle_id_prefix;
             [self prepend_apps_item:list index:i menu:dock_apps_menu];
     }
 
-    self.apps = list;
+    apps = [list retain];
 }
 
-- (void) set_window_menu:(NSArray <NSArray <NSString *> *> *)list
+- (void) set_window_menu:(NSArray *)list
 {
-    NSMenu * const menu = X11App.windowsMenu;
-    NSMenu * const dock_menu = self.dock_menu;
-
-    /* First, remove the existing items from the Window Menu */
-    NSInteger itemsToRemove = self.windows_menu_nitems;
-    if (itemsToRemove > 0) {
-        NSInteger indexForRemoval = menu.numberOfItems - itemsToRemove - 1; /* we also want to remove the separator */
-
-        for (NSInteger i = 0 ; i < itemsToRemove + 1 ; i++) {
-            [menu removeItemAtIndex:indexForRemoval];
-        }
-
-        for (NSInteger i = 0 ; i < itemsToRemove; i++) {
-            [dock_menu removeItemAtIndex:0];
-        }
-    }
-
-    NSInteger const itemsToAdd = list.count;
-    self.windows_menu_nitems = itemsToAdd;
+    [self remove_window_menu];
+    [self install_window_menu:list];
 
-    if (itemsToAdd > 0) {
-        NSMenuItem *item;
-
-        // Push a Separator
-        [menu addItem:[NSMenuItem separatorItem]];
-
-        for (NSInteger i = 0; i < itemsToAdd; i++) {
-            NSString *name, *shortcut;
-
-            name = list[i][0];
-            shortcut = list[i][1];
-
-            if (windowItemModMask == 0 || windowItemModMask == -1)
-                shortcut = @"";
-
-            item = (NSMenuItem *)[menu addItemWithTitle:name
-                                                 action:@selector(item_selected:)
-                                          keyEquivalent:shortcut];
-            [item setKeyEquivalentModifierMask:(NSUInteger)windowItemModMask];
-            [item setTarget:self];
-            [item setTag:i];
-            [item setEnabled:YES];
-
-            item = (NSMenuItem *)[dock_menu  insertItemWithTitle:name
-                                                          action:@selector(item_selected:)
-                                                   keyEquivalent:shortcut
-                                                         atIndex:i];
-            [item setKeyEquivalentModifierMask:(NSUInteger)windowItemModMask];
-            [item setTarget:self];
-            [item setTag:i];
-            [item setEnabled:YES];
-        }
-
-        int const checked_window_item = self.checked_window_item;
-        if (checked_window_item >= 0 && checked_window_item < itemsToAdd) {
-            NSInteger first = menu.numberOfItems - itemsToAdd;
-            item = (NSMenuItem *)[menu itemAtIndex:first + checked_window_item];
-            [item setState:NSOnState];
-
-            item = (NSMenuItem *)[dock_menu itemAtIndex:checked_window_item];
-            [item setState:NSOnState];
-        }
-    }
-
-    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMWindowMenuNotify);
+    DarwinSendDDXEvent(kXquartzControllerNotify, 1,
+                       AppleWMWindowMenuNotify);
 }
 
 - (void) set_window_menu_check:(NSNumber *)nn
 {
-    NSMenu * const menu = X11App.windowsMenu;
-    NSMenu * const dock_menu = self.dock_menu;
+    NSMenu *menu;
     NSMenuItem *item;
-    int n = nn.intValue;
+    int first, count;
+    int n = [nn intValue];
 
-    NSInteger const count = self.windows_menu_nitems;
-    NSInteger const first = menu.numberOfItems - count;
-
-    int const checked_window_item = self.checked_window_item;
+    menu = [X11App windowsMenu];
+    first = windows_menu_start + 1;
+    count = [menu numberOfItems] - first;
 
     if (checked_window_item >= 0 && checked_window_item < count) {
         item = (NSMenuItem *)[menu itemAtIndex:first + checked_window_item];
@@ -298,10 +299,10 @@ extern char *bundle_id_prefix;
         item = (NSMenuItem *)[dock_menu itemAtIndex:n];
         [item setState:NSOnState];
     }
-    self.checked_window_item = n;
+    checked_window_item = n;
 }
 
-- (void) set_apps_menu:(NSArray <NSArray <NSString *> *> *)list
+- (void) set_apps_menu:(NSArray *)list
 {
     [self remove_apps_menu];
     [self install_apps_menu:list];
@@ -310,29 +311,31 @@ extern char *bundle_id_prefix;
 #ifdef XQUARTZ_SPARKLE
 - (void) setup_sparkle
 {
-    if (self.check_for_updates_item)
+    if (check_for_updates_item)
         return;  // already did it...
 
-    NSMenu *menu = [self.x11_about_item menu];
+    NSMenu *menu = [x11_about_item menu];
 
-    NSMenuItem * const check_for_updates_item =
-        [menu insertItemWithTitle:NSLocalizedString(@"Check for X11 Updates...", @"Check for X11 Updates...")
-                           action:@selector(checkForUpdates:)
-                    keyEquivalent:@""
-                          atIndex:1];
+    check_for_updates_item =
+        [menu insertItemWithTitle:NSLocalizedString(
+             @"Check for X11 Updates...",
+             @"Check for X11 Updates...")
+         action:@selector (
+             checkForUpdates:)
+         keyEquivalent:@""
+         atIndex:1];
     [check_for_updates_item setTarget:[SUUpdater sharedUpdater]];
     [check_for_updates_item setEnabled:YES];
 
-    self.check_for_updates_item = check_for_updates_item;
-
     // Set X11Controller as the delegate for the updater.
     [[SUUpdater sharedUpdater] setDelegate:self];
 }
 
 // Sent immediately before installing the specified update.
-- (void)updater:(SUUpdater *)updater willInstallUpdate:(SUAppcastItem *)update
+- (void)updater:(SUUpdater *)updater willInstallUpdate:(SUAppcastItem *)
+   update
 {
-    //self.can_quit = YES;
+    //[self set_can_quit:YES];
 }
 
 #endif
@@ -344,8 +347,10 @@ extern char *bundle_id_prefix;
     const char *newargv[4];
     char buf[128];
     char *s;
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
     int stdout_pipe[2];
     int stderr_pipe[2];
+#endif
 
     newargv[0] = [X11App prefs_get_string:@PREFS_LOGIN_SHELL default:"/bin/sh"];
     newargv[1] = "-c";
@@ -358,6 +363,7 @@ extern char *bundle_id_prefix;
         setenv("DISPLAY", buf, TRUE);
     }
 
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
     if (&asl_log_descriptor) {
         char *asl_sender;
         aslmsg amsg = asl_new(ASL_TYPE_MSG);
@@ -389,6 +395,7 @@ extern char *bundle_id_prefix;
 
         asl_free(amsg);
     }
+#endif
 
     /* Do the fork-twice trick to avoid having to reap zombies */
     child1 = fork();
@@ -406,11 +413,13 @@ extern char *bundle_id_prefix;
             _exit(1);
 
         case 0:                                     /* child2 */
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
             if (&asl_log_descriptor) {
                 /* Replace our stdout/stderr */
                 dup2(stdout_pipe[1], STDOUT_FILENO);
                 dup2(stderr_pipe[1], STDERR_FILENO);
             }
+#endif
 
             /* close all open files except for standard streams */
             max_files = sysconf(_SC_OPEN_MAX);
@@ -433,18 +442,19 @@ extern char *bundle_id_prefix;
         waitpid(child1, &status, 0);
     }
 
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
     if (&asl_log_descriptor) {
         /* Close the write ends of the pipe */
         close(stdout_pipe[1]);
         close(stderr_pipe[1]);
     }
+#endif
 }
 
 - (void) app_selected:sender
 {
     int tag;
     NSString *item;
-    NSArray <NSArray <NSString *> *> * const apps = self.apps;
 
     tag = [sender tag] - 1;
     if (apps == nil || tag < 0 || tag >= [apps count])
@@ -458,18 +468,14 @@ extern char *bundle_id_prefix;
 - (IBAction) apps_table_show:sender
 {
     NSArray *columns;
-    NSMutableArray <NSMutableArray <NSString *> *> * const oldapps = self.table_apps;
-    NSTableView * const apps_table = self.apps_table;
+    NSMutableArray *oldapps = nil;
 
-    NSMutableArray <NSMutableArray <NSString *> *> * const table_apps = [[NSMutableArray alloc] initWithCapacity:1];
-    self.table_apps = table_apps;
+    if (table_apps != nil)
+        oldapps = table_apps;
 
-    NSArray <NSArray <NSString *> *> * const apps = self.apps;
-    if (apps != nil) {
-        for (NSArray <NSString *> * row in apps) {
-            [table_apps addObject:row.mutableCopy];
-        }
-    }
+    table_apps = [[NSMutableArray alloc] initWithCapacity:1];
+    if (apps != nil)
+        [table_apps addObjectsFromArray:apps];
 
     columns = [apps_table tableColumns];
     [[columns objectAtIndex:0] setIdentifier:@"0"];
@@ -488,8 +494,6 @@ extern char *bundle_id_prefix;
 
 - (IBAction) apps_table_done:sender
 {
-    NSMutableArray <NSMutableArray <NSString *> *> * const table_apps = self.table_apps;
-    NSTableView * const apps_table = self.apps_table;
     [apps_table deselectAll:sender];    /* flush edits? */
 
     [self remove_apps_menu];
@@ -500,14 +504,13 @@ extern char *bundle_id_prefix;
 
     [[apps_table window] orderOut:sender];
 
-    self.table_apps = nil;
+    [table_apps release];
+    table_apps = nil;
 }
 
 - (IBAction) apps_table_new:sender
 {
     NSMutableArray *item;
-    NSMutableArray <NSMutableArray <NSString *> *> * const table_apps = self.table_apps;
-    NSTableView * const apps_table = self.apps_table;
 
     int row = [apps_table selectedRow], i;
 
@@ -535,10 +538,8 @@ extern char *bundle_id_prefix;
 
 - (IBAction) apps_table_duplicate:sender
 {
-    NSMutableArray <NSMutableArray <NSString *> *> * const table_apps = self.table_apps;
-    NSTableView * const apps_table = self.apps_table;
     int row = [apps_table selectedRow], i;
-    NSMutableArray <NSString *> *item;
+    NSObject *item;
 
     if (row < 0) {
         [self apps_table_new:sender];
@@ -561,8 +562,6 @@ extern char *bundle_id_prefix;
 
 - (IBAction) apps_table_delete:sender
 {
-    NSMutableArray <NSMutableArray <NSString *> *> * const table_apps = self.table_apps;
-    NSTableView * const apps_table = self.apps_table;
     int row = [apps_table selectedRow];
 
     if (row >= 0) {
@@ -585,7 +584,6 @@ extern char *bundle_id_prefix;
 
 - (NSInteger) numberOfRowsInTableView:(NSTableView *)tableView
 {
-    NSMutableArray <NSMutableArray <NSString *> *> * const table_apps = self.table_apps;
     if (table_apps == nil) return 0;
 
     return [table_apps count];
@@ -594,7 +592,6 @@ extern char *bundle_id_prefix;
 - (id)             tableView:(NSTableView *)tableView
    objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
 {
-    NSMutableArray <NSMutableArray <NSString *> *> * const table_apps = self.table_apps;
     NSArray *item;
     int col;
 
@@ -612,8 +609,7 @@ extern char *bundle_id_prefix;
 - (void) tableView:(NSTableView *)tableView setObjectValue:(id)object
     forTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
 {
-    NSMutableArray <NSMutableArray <NSString *> *> * const table_apps = self.table_apps;
-    NSMutableArray <NSString *> *item;
+    NSMutableArray *item;
     int col;
 
     if (table_apps == nil) return;
@@ -673,10 +669,11 @@ extern char *bundle_id_prefix;
 
 - (IBAction) enable_fullscreen_changed:sender
 {
-    XQuartzRootlessDefault = !self.enable_fullscreen.intValue;
+    XQuartzRootlessDefault = ![enable_fullscreen intValue];
 
-    [self.enable_fullscreen_menu setEnabled:!XQuartzRootlessDefault];
-    [self.enable_fullscreen_menu_text setTextColor:XQuartzRootlessDefault ? NSColor.disabledControlTextColor : NSColor.controlTextColor];
+    [enable_fullscreen_menu setEnabled:!XQuartzRootlessDefault];
+    [enable_fullscreen_menu_text setTextColor:XQuartzRootlessDefault ?[
+         NSColor disabledControlTextColor] : [NSColor controlTextColor]];
 
     DarwinSendDDXEvent(kXquartzSetRootless, 1, XQuartzRootlessDefault);
 
@@ -689,85 +686,102 @@ extern char *bundle_id_prefix;
     DarwinSendDDXEvent(kXquartzToggleFullscreen, 0);
 }
 
+- (void) set_can_quit:(OSX_BOOL)state
+{
+    can_quit = state;
+}
+
 - (IBAction)prefs_changed:sender
 {
     if (!sender)
         return;
 
-    if (sender == self.fake_buttons) {
-        darwinFakeButtons = self.fake_buttons.intValue;
+    if (sender == fake_buttons) {
+        darwinFakeButtons = [fake_buttons intValue];
         [NSApp prefs_set_boolean:@PREFS_FAKEBUTTONS value:darwinFakeButtons];
     }
-    else if (sender == self.enable_keyequivs) {
-        XQuartzEnableKeyEquivalents = self.enable_keyequivs.intValue;
+    else if (sender == enable_keyequivs) {
+        XQuartzEnableKeyEquivalents = [enable_keyequivs intValue];
         [NSApp prefs_set_boolean:@PREFS_KEYEQUIVS value:
          XQuartzEnableKeyEquivalents];
     }
-    else if (sender == self.sync_keymap) {
-        darwinSyncKeymap = self.sync_keymap.intValue;
+    else if (sender == sync_keymap) {
+        darwinSyncKeymap = [sync_keymap intValue];
         [NSApp prefs_set_boolean:@PREFS_SYNC_KEYMAP value:darwinSyncKeymap];
     }
-    else if (sender == self.enable_fullscreen_menu) {
-        XQuartzFullscreenMenu = self.enable_fullscreen_menu.intValue;
+    else if (sender == enable_fullscreen_menu) {
+        XQuartzFullscreenMenu = [enable_fullscreen_menu intValue];
         [NSApp prefs_set_boolean:@PREFS_FULLSCREEN_MENU value:
          XQuartzFullscreenMenu];
     }
-    else if (sender == self.option_sends_alt) {
+    else if (sender == option_sends_alt) {
         BOOL prev_opt_sends_alt = XQuartzOptionSendsAlt;
 
-        XQuartzOptionSendsAlt = self.option_sends_alt.intValue;
+        XQuartzOptionSendsAlt = [option_sends_alt intValue];
         [NSApp prefs_set_boolean:@PREFS_OPTION_SENDS_ALT value:
-        XQuartzOptionSendsAlt];
+         XQuartzOptionSendsAlt];
 
         if (prev_opt_sends_alt != XQuartzOptionSendsAlt)
             QuartsResyncKeymap(TRUE);
     }
-    else if (sender == self.click_through) {
-        [NSApp prefs_set_boolean:@PREFS_CLICK_THROUGH value:self.click_through.intValue];
+    else if (sender == click_through) {
+        [NSApp prefs_set_boolean:@PREFS_CLICK_THROUGH value:[click_through
+                                                             intValue]];
     }
-    else if (sender == self.focus_follows_mouse) {
-        [NSApp prefs_set_boolean:@PREFS_FFM value:self.focus_follows_mouse.intValue];
+    else if (sender == focus_follows_mouse) {
+        [NSApp prefs_set_boolean:@PREFS_FFM value:[focus_follows_mouse
+                                                   intValue]];
     }
-    else if (sender == self.focus_on_new_window) {
-        [NSApp prefs_set_boolean:@PREFS_FOCUS_ON_NEW_WINDOW value:self.focus_on_new_window.intValue];
+    else if (sender == focus_on_new_window) {
+        [NSApp prefs_set_boolean:@PREFS_FOCUS_ON_NEW_WINDOW value:[
+             focus_on_new_window intValue]];
     }
-    else if (sender == self.enable_auth) {
-        [NSApp prefs_set_boolean:@PREFS_NO_AUTH value:!self.enable_auth.intValue];
+    else if (sender == enable_auth) {
+        [NSApp prefs_set_boolean:@PREFS_NO_AUTH value:![enable_auth intValue]
+        ];
     }
-    else if (sender == self.enable_tcp) {
-        [NSApp prefs_set_boolean:@PREFS_NO_TCP value:!self.enable_tcp.intValue];
+    else if (sender == enable_tcp) {
+        [NSApp prefs_set_boolean:@PREFS_NO_TCP value:![enable_tcp intValue]];
     }
-    else if (sender == self.depth) {
-        [NSApp prefs_set_integer:@PREFS_DEPTH value:self.depth.selectedTag];
+    else if (sender == depth) {
+        [NSApp prefs_set_integer:@PREFS_DEPTH value:[depth selectedTag]];
     }
-    else if (sender == self.sync_pasteboard) {
-        BOOL pbproxy_active = self.sync_pasteboard.intValue;
+    else if (sender == sync_pasteboard) {
+        BOOL pbproxy_active = [sync_pasteboard intValue];
         [NSApp prefs_set_boolean:@PREFS_SYNC_PB value:pbproxy_active];
 
-        [self.sync_pasteboard_to_clipboard setEnabled:pbproxy_active];
-        [self.sync_pasteboard_to_primary setEnabled:pbproxy_active];
-        [self.sync_clipboard_to_pasteboard setEnabled:pbproxy_active];
-        [self.sync_primary_immediately setEnabled:pbproxy_active];
+        [sync_pasteboard_to_clipboard setEnabled:pbproxy_active];
+        [sync_pasteboard_to_primary setEnabled:pbproxy_active];
+        [sync_clipboard_to_pasteboard setEnabled:pbproxy_active];
+        [sync_primary_immediately setEnabled:pbproxy_active];
 
         // setEnabled doesn't do this...
-        [self.sync_text1 setTextColor:pbproxy_active ? NSColor.controlTextColor : NSColor.disabledControlTextColor];
-        [self.sync_text2 setTextColor:pbproxy_active ? NSColor.controlTextColor : NSColor.disabledControlTextColor];
+        [sync_text1 setTextColor:pbproxy_active ?[NSColor controlTextColor] :
+         [NSColor disabledControlTextColor]];
+        [sync_text2 setTextColor:pbproxy_active ?[NSColor controlTextColor] :
+         [NSColor disabledControlTextColor]];
     }
-    else if (sender == self.sync_pasteboard_to_clipboard) {
-        [NSApp prefs_set_boolean:@PREFS_SYNC_PB_TO_CLIPBOARD value:self.sync_pasteboard_to_clipboard.intValue];
+    else if (sender == sync_pasteboard_to_clipboard) {
+        [NSApp prefs_set_boolean:@PREFS_SYNC_PB_TO_CLIPBOARD value:[
+             sync_pasteboard_to_clipboard intValue]];
     }
-    else if (sender == self.sync_pasteboard_to_primary) {
-        [NSApp prefs_set_boolean:@PREFS_SYNC_PB_TO_PRIMARY value:self.sync_pasteboard_to_primary.intValue];
+    else if (sender == sync_pasteboard_to_primary) {
+        [NSApp prefs_set_boolean:@PREFS_SYNC_PB_TO_PRIMARY value:[
+             sync_pasteboard_to_primary intValue]];
     }
-    else if (sender == self.sync_clipboard_to_pasteboard) {
-        [NSApp prefs_set_boolean:@PREFS_SYNC_CLIPBOARD_TO_PB value:self.sync_clipboard_to_pasteboard.intValue];
+    else if (sender == sync_clipboard_to_pasteboard) {
+        [NSApp prefs_set_boolean:@PREFS_SYNC_CLIPBOARD_TO_PB value:[
+             sync_clipboard_to_pasteboard intValue]];
     }
-    else if (sender == self.sync_primary_immediately) {
-        [NSApp prefs_set_boolean:@PREFS_SYNC_PRIMARY_ON_SELECT value:self.sync_primary_immediately.intValue];
+    else if (sender == sync_primary_immediately) {
+        [NSApp prefs_set_boolean:@PREFS_SYNC_PRIMARY_ON_SELECT value:[
+             sync_primary_immediately intValue]];
     }
-    else if (sender == self.scroll_in_device_direction) {
-        XQuartzScrollInDeviceDirection = self.scroll_in_device_direction.intValue;
-        [NSApp prefs_set_boolean:@PREFS_SCROLL_IN_DEV_DIRECTION value:XQuartzScrollInDeviceDirection];
+    else if (sender == scroll_in_device_direction) {
+        XQuartzScrollInDeviceDirection =
+            [scroll_in_device_direction intValue];
+        [NSApp prefs_set_boolean:@PREFS_SCROLL_IN_DEV_DIRECTION value:
+         XQuartzScrollInDeviceDirection];
     }
 
     [NSApp prefs_synchronize];
@@ -780,42 +794,71 @@ extern char *bundle_id_prefix;
     BOOL pbproxy_active =
         [NSApp prefs_get_boolean:@PREFS_SYNC_PB default:YES];
 
-    [self.scroll_in_device_direction setIntValue:XQuartzScrollInDeviceDirection];
-
-    [self.fake_buttons setIntValue:darwinFakeButtons];
-    [self.enable_keyequivs setIntValue:XQuartzEnableKeyEquivalents];
-    [self.sync_keymap setIntValue:darwinSyncKeymap];
-    [self.option_sends_alt setIntValue:XQuartzOptionSendsAlt];
-    [self.click_through setIntValue:[NSApp prefs_get_boolean:@PREFS_CLICK_THROUGH default:NO]];
-    [self.focus_follows_mouse setIntValue:[NSApp prefs_get_boolean:@PREFS_FFM default:NO]];
-    [self.focus_on_new_window setIntValue:[NSApp prefs_get_boolean:@PREFS_FOCUS_ON_NEW_WINDOW default:YES]];
-
-    [self.enable_auth setIntValue:![NSApp prefs_get_boolean:@PREFS_NO_AUTH default:NO]];
-    [self.enable_tcp setIntValue:![NSApp prefs_get_boolean:@PREFS_NO_TCP default:NO]];
-
-    [self.depth selectItemAtIndex:[self.depth indexOfItemWithTag:[NSApp prefs_get_integer:@PREFS_DEPTH default:-1]]];
-
-    [self.sync_pasteboard setIntValue:pbproxy_active];
-    [self.sync_pasteboard_to_clipboard setIntValue:[NSApp prefs_get_boolean:@PREFS_SYNC_PB_TO_CLIPBOARD default:YES]];
-    [self.sync_pasteboard_to_primary setIntValue:[NSApp prefs_get_boolean:@PREFS_SYNC_PB_TO_PRIMARY default:YES]];
-    [self.sync_clipboard_to_pasteboard setIntValue:[NSApp prefs_get_boolean:@PREFS_SYNC_CLIPBOARD_TO_PB default:YES]];
-    [self.sync_primary_immediately setIntValue:[NSApp prefs_get_boolean:@PREFS_SYNC_PRIMARY_ON_SELECT default:NO]];
-
-    [self.sync_pasteboard_to_clipboard setEnabled:pbproxy_active];
-    [self.sync_pasteboard_to_primary setEnabled:pbproxy_active];
-    [self.sync_clipboard_to_pasteboard setEnabled:pbproxy_active];
-    [self.sync_primary_immediately setEnabled:pbproxy_active];
+    // Remove preferences from the GUI which are not supported
+    // TODO: Change 1117 to NSAppKitVersionNumber10_7 when it is defined
+    if (scroll_in_device_direction && NSAppKitVersionNumber < 1117) {
+        [scroll_in_device_direction removeFromSuperview];
+        scroll_in_device_direction = nil;
+    }
+    else {
+        [scroll_in_device_direction setIntValue:
+         XQuartzScrollInDeviceDirection];
+    }
+
+    [fake_buttons setIntValue:darwinFakeButtons];
+    [enable_keyequivs setIntValue:XQuartzEnableKeyEquivalents];
+    [sync_keymap setIntValue:darwinSyncKeymap];
+    [option_sends_alt setIntValue:XQuartzOptionSendsAlt];
+    [click_through setIntValue:[NSApp prefs_get_boolean:@PREFS_CLICK_THROUGH
+                                default:NO]];
+    [focus_follows_mouse setIntValue:[NSApp prefs_get_boolean:@PREFS_FFM
+                                      default:NO]];
+    [focus_on_new_window setIntValue:[NSApp prefs_get_boolean:
+                                      @PREFS_FOCUS_ON_NEW_WINDOW default:YES]
+    ];
+
+    [enable_auth setIntValue:![NSApp prefs_get_boolean:@PREFS_NO_AUTH default
+                               :NO]];
+    [enable_tcp setIntValue:![NSApp prefs_get_boolean:@PREFS_NO_TCP default:
+                              NO]];
+
+    [depth selectItemAtIndex:[depth indexOfItemWithTag:[NSApp
+                                                        prefs_get_integer:
+                                                        @PREFS_DEPTH default:
+                                                        -1]]];
+
+    [sync_pasteboard setIntValue:pbproxy_active];
+    [sync_pasteboard_to_clipboard setIntValue:[NSApp prefs_get_boolean:
+                                               @PREFS_SYNC_PB_TO_CLIPBOARD
+                                               default:YES]];
+    [sync_pasteboard_to_primary setIntValue:[NSApp prefs_get_boolean:
+                                             @PREFS_SYNC_PB_TO_PRIMARY
+                                             default:YES]];
+    [sync_clipboard_to_pasteboard setIntValue:[NSApp prefs_get_boolean:
+                                               @PREFS_SYNC_CLIPBOARD_TO_PB
+                                               default:YES]];
+    [sync_primary_immediately setIntValue:[NSApp prefs_get_boolean:
+                                           @PREFS_SYNC_PRIMARY_ON_SELECT
+                                           default:NO]];
+
+    [sync_pasteboard_to_clipboard setEnabled:pbproxy_active];
+    [sync_pasteboard_to_primary setEnabled:pbproxy_active];
+    [sync_clipboard_to_pasteboard setEnabled:pbproxy_active];
+    [sync_primary_immediately setEnabled:pbproxy_active];
 
     // setEnabled doesn't do this...
-    [self.sync_text1 setTextColor:pbproxy_active ? NSColor.controlTextColor : NSColor.disabledControlTextColor];
-    [self.sync_text2 setTextColor:pbproxy_active ? NSColor.controlTextColor : NSColor.disabledControlTextColor];
+    [sync_text1 setTextColor:pbproxy_active ?[NSColor controlTextColor] : [
+         NSColor disabledControlTextColor]];
+    [sync_text2 setTextColor:pbproxy_active ?[NSColor controlTextColor] : [
+         NSColor disabledControlTextColor]];
 
-    [self.enable_fullscreen setIntValue:!XQuartzRootlessDefault];
-    [self.enable_fullscreen_menu setIntValue:XQuartzFullscreenMenu];
-    [self.enable_fullscreen_menu setEnabled:!XQuartzRootlessDefault];
-    [self.enable_fullscreen_menu_text setTextColor:XQuartzRootlessDefault ? NSColor.disabledControlTextColor : NSColor.controlTextColor];
+    [enable_fullscreen setIntValue:!XQuartzRootlessDefault];
+    [enable_fullscreen_menu setIntValue:XQuartzFullscreenMenu];
+    [enable_fullscreen_menu setEnabled:!XQuartzRootlessDefault];
+    [enable_fullscreen_menu_text setTextColor:XQuartzRootlessDefault ?[
+         NSColor disabledControlTextColor] : [NSColor controlTextColor]];
 
-    [self.prefs_panel makeKeyAndOrderFront:sender];
+    [prefs_panel makeKeyAndOrderFront:sender];
 }
 
 - (IBAction) quit:sender
@@ -825,18 +868,23 @@ extern char *bundle_id_prefix;
 
 - (IBAction) x11_help:sender
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1060 || defined __ppc__
+    AHLookupAnchor((CFStringRef)NSLocalizedString(@"Mac Help",
+                                                  no comment),
+                   CFSTR("mchlp2276"));
+#else
     AHLookupAnchor(CFSTR("com.apple.machelp"), CFSTR("mchlp2276"));
+#endif
 }
 
 - (OSX_BOOL) validateMenuItem:(NSMenuItem *)item
 {
     NSMenu *menu = [item menu];
-    NSMenu * const dock_menu = self.dock_menu;
 
-    if (item == self.toggle_fullscreen_item)
+    if (item == toggle_fullscreen_item)
         return !XQuartzIsRootless;
     else if (menu == [X11App windowsMenu] || menu == dock_menu
-             || (menu == [self.x11_about_item menu] && [item tag] == 42))
+             || (menu == [x11_about_item menu] && [item tag] == 42))
         return (AppleWMSelectedEvents() & AppleWMControllerNotifyMask) != 0;
     else
         return TRUE;
@@ -864,7 +912,7 @@ extern char *bundle_id_prefix;
     NSString *msg;
     NSString *title;
 
-    if (self.can_quit ||
+    if (can_quit ||
         [X11App prefs_get_boolean:@PREFS_NO_QUIT_ALERT default:NO])
         return NSTerminateNow;
 
@@ -903,26 +951,26 @@ extern char *bundle_id_prefix;
 {
     x_list *node;
 
-    self.finished_launching = YES;
+    finished_launching = YES;
 
-    for (node = self.pending_apps; node != NULL; node = node->next) {
+    for (node = pending_apps; node != NULL; node = node->next) {
         NSString *filename = node->data;
         [self launch_client:filename];
         [filename release];
     }
 
-    x_list_free(self.pending_apps);
-    self.pending_apps = NULL;
+    x_list_free(pending_apps);
+    pending_apps = NULL;
 }
 
 - (OSX_BOOL) application:(NSApplication *)app openFile:(NSString *)filename
 {
     const char *name = [filename UTF8String];
 
-    if (self.finished_launching)
+    if (finished_launching)
         [self launch_client:filename];
     else if (name[0] != ':')            /* ignore display names */
-        self.pending_apps = x_list_prepend(self.pending_apps, [filename retain]);
+        pending_apps = x_list_prepend(pending_apps, [filename retain]);
 
     /* FIXME: report failures. */
     return YES;
diff --git a/hw/xquartz/quartzCommon.h b/hw/xquartz/quartzCommon.h
new file mode 100644
index 000000000..721886b87
--- /dev/null
+++ b/hw/xquartz/quartzCommon.h
@@ -0,0 +1,55 @@
+/*
+ * quartzCommon.h
+ *
+ * Common definitions used internally by all Quartz modes
+ *
+ * This file should be included before any X11 or IOKit headers
+ * so that it can avoid symbol conflicts.
+ *
+ * Copyright (c) 2001-2004 Torrey T. Lyons and Greg Parker.
+ *                 All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifndef _QUARTZCOMMON_H
+#define _QUARTZCOMMON_H
+
+#include <X11/Xdefs.h>
+#include "privates.h"
+
+// Other shared data
+extern DevPrivateKeyRec quartzScreenKeyRec;
+#define quartzScreenKey (&quartzScreenKeyRec)
+extern int aquaMenuBarHeight;
+
+// Name of GLX bundle for native OpenGL
+extern const char      *quartzOpenGLBundle;
+
+void
+QuartzBlockHandler(void *blockData, void *pTimeout);
+
+void
+QuartzWakeupHandler(void *blockData, int result);
+
+#endif  /* _QUARTZCOMMON_H */
-- 
2.46.0

